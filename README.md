# C minus minus

A compiler for a C-like programming language, with a reduced set of instructions.

## Table of Contents

- [Summary](#summary)
- [Motivation and Problem to Solve](#motivation-and-problem-to-solve)
- [Project Objectives](#project-objectives)
- [State of the Art](#state-of-the-art)
- [Compiler Architecture and Design](#compiler-architecture-and-design)
  - [Block Diagram](#block-diagram)
  - [Data Flow Explanation](#data-flow-explanation)
  - [Design Decisions](#design-decisions)
- [Lexical Analysis](#lexical-analysis)
  - [Automata](#automata)
- [Syntax Analysis](#syntax-analysis)
- [Semantic Analysis](#semantic-analysis)
- [Installation and Running](#installation-and-running)
- [Testing and Validation](#testing-and-validation)
- [Tools and Development Environment](#tools-and-development-environment)
- [Demonstration](#demonstration)
- [Challenges and Solutions](#challenges-and-solutions)
- [Conclusions and Future Work](#conclusions-and-future-work)
- [References](#references)

## Summary

This project aims to develop a complete compiler, covering everything from lexical analysis to final code generation. The compiler will allow for the translation of source code written in a C-- into machine code.

## Motivation and Problem to Solve

- **Problem Description:** We aim to expand our knowledge by creating a compiler, as building one is a powerful way to gain a deep understanding of how compilers work. And what better way to do this than by creating a compiler for a C-like language?
- **Importance:** An efficient compiler is essential for any development environment, as it directly impacts developer productivity and the quality of the final product. Moreover, having a custom compiler allows for greater customization and optimization for specific use cases.
- **Use Cases:** This compiler will be useful in both academic and industrial settings, enabling the compilation of C++ code and its adaptation to various architectures and platforms. It will also serve as a teaching and experimentation tool in compiler courses.

## Project Objectives

- Develop a lexical analyzer that correctly identifies and classifies the lexical units of the input language.
  -Implement a syntax analyzer that constructs abstract syntax trees (AST) from the tokens generated by the lexical analyzer.
- Create a semantic analyzer that checks the coherence and correctness of the source code in terms of data types, variable scope, and language rules.
- Design a code generator that translates the AST into machine code or an intermediate code optimized for efficient execution.
- Include additional optimizations in the code generation to improve the efficiency of the compiled code.
- Develop an error handler that identifies, reports, and suggests solutions to lexical, syntactic, and semantic errors.

## State of the art

- **Similar Compilers:** GCC, Clang, and other compilers that support C/C++ and provide advanced analysis, code optimization, and machine code generation.
- **Limitations of Current Solutions:** Many current compilers can be difficult to adapt or customize for specific needs. They can also be complex and hard to learn for those just starting in compiler development.
- **Justification for the New Compiler:** This project aims to create a modular and extensible compiler that is not only efficient but also easy to understand and modify. It focuses on a structure that allows for the incorporation of new features and optimizations without needing to restructure the entire compiler.

## Compiler Architecture and Design

- **Block Diagram:**
- **Data Flow Explanation:**
- **Design Decisions:**

## Lexical Analysis

### Lexical Analysis

- Tokenization, identification of keywords, operators, etc.
- Keywords, tokens, identifiers, etc., are the same as those in the C language.

### Automata

Both or this DFA are the same, but were broken down into 2 images to view more easily.  
![Automata Compilador identifier, keyword](https://github.com/user-attachments/assets/695c0dce-311f-41f3-afb7-6a2bc6482d45)
![Automata Compilador operator, constant, punctiation](https://github.com/user-attachments/assets/335a3b7c-0970-485b-887f-e8e05a3d3649)

## Syntax Analysis

- **Syntax analysis:**

  - Use of grammars and syntax trees.

- **Examples:**

## Semantic Analysis

- **Semantic analysis:**

  - Use of grammars and syntax trees.

- **Examples:**

## Installation and Running

### Prerequisites

If you don't have Conan installed, run the following:

```bash
pip install conan
conan profile detect
```

### Install Conan packages (gtest)

From the root of the project directory, run the following command to install Conan packages:

```bash
conan install . --build=missing --output-folder=build -s build_type=Debug
```

### Build the Project

To build the project, run the following:

```bash
cd build/
cmake ..
cmake --build .
```

### Build and Run the Project

To build and run the project, execute:

```bash
cd build/
cmake --build . --target run
```

## Testing and Validation

- **Testing methodology:**
- **Results obtained:**
- **Specific test cases:**

## Tools and Development Environment

- **Programming languages used:**
- **Development tools:**
- **Testing and simulation environment:**

## Demonstration

- **Source code example:**
- **Compilation process:**
- **Execution of compiled code:**

## Challenges and Solutions

- **Technical or design problems:**
- **Strategies adopted to overcome challenges:**
- **Lessons learned:**

## Conclusions and Future Work

- **Summary of objectives achieved:**
- **Performance evaluation:**
- **Proposals for future improvements:**

## References

- Cooper, K., & Torczon, L. (2011). Engineering a compiler (2nd ed.). Morgan Kaufmann.
